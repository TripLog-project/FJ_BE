<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    function solution() {
      // let word = "a"
      
      // let lower = []
      // let upper = []
      
      // let answer = []

      // for (let i = 97; i <= 122; i++) lower.push(String.fromCharCode(i))
      // for (let i = 65; i <= 90; i++) upper.push(String.fromCharCode(i))
      // const ALPHASIZE = lower.length

      // let a = [...lower].reverse()
      // console.log(a)

      // let b = [...upper].reverse()
      // console.log(b)

      
      // console.log(lower)
      // console.log(upper)
      // console.log(ALPHASIZE)

      let [left, right] = pages;

      let pobi = [201, 202]
      let crong = [399, 400]

      // 왼쪽 페이지가 오른쪽 페이지보다 크거나 같을 경우(예외처리)

      if (1 <= left && left < 400 && left % 2 == 1 && left + 1 == right) {
        return true;
      }
      if(pobi[0] >= pobi[1] || crong[0] >= crong[1]) {
        return -1
      }

      // 왼쪽 페이지 홀, 짝 판별(예외처리)
      if(pobi[0] % 2 === 0 || crong[0] % 2 === 0) {
        return -1
      } 

      // 오른쪽 페이지 홀, 짝 판별(예외처리)
      if (pobi[1] % 2 === 1 || crong[1] % 2 === 1) {
        return -1
      }

      // 왼쪽 페이지와 오른쪽 페이지의 차이가 1이 아닐 경우(예외처리)
      if (pobi[1] - pobi[0] !== 1 || crong[1] - crong[0] !== 1) {
        return -1
      }

      // 배열을 잘라서 보관
      let pobiArr = pobi.join("").split("");
      let crongArr = crong.join("").split("");

      // 포비의 왼쪽 페이지 가장 큰 값 저장
      let pobiLeftMax = Math.max(
        pobiArr.slice(0, pobiArr.length / 2).reduce((a, b) => parseInt(a) + parseInt(b)),
        pobiArr.slice(0, pobiArr.length / 2).reduce((a, b) => parseInt(a) * parseInt(b)),
      );

      // 포비의 오른쪽 페이지 가장 큰 값 저장
      let pobiRightMax = Math.max(
        pobiArr.slice(pobiArr.length / 2).reduce((a, b) => parseInt(a) + parseInt(b)),
        pobiArr.slice(pobiArr.length / 2).reduce((a, b) => parseInt(a) * parseInt(b)),
      );

      // 포비의 왼쪽, 오른쪽 페이지 중 가장 큰 값
      let pobiMax = Math.max(pobiLeftMax, pobiRightMax)
      
      // 크롱의 왼쪽 페이지 가장 큰 값 저장
      let crongLeftMax = Math.max(
        crongArr.slice(0, crongArr.length / 2).reduce((a, b) => parseInt(a) + parseInt(b)),
        crongArr.slice(0, crongArr.length / 2).reduce((a, b) => parseInt(a) * parseInt(b)),
      );

      // 크롱의 오른쪽 페이지 가장 큰 값 저장
      let crongRightMax = Math.max(
        crongArr.slice(crongArr.length / 2).reduce((a, b) => parseInt(a) + parseInt(b)),
        crongArr.slice(crongArr.length / 2).reduce((a, b) => parseInt(a) * parseInt(b)),
      );

      // 크롱의 왼쪽, 오른쪽 페이지 중 가장 큰 값
      let crongMax = Math.max(crongLeftMax, crongRightMax)

      // 포비와 크롱이 같을 경우 0점
      if (pobiMax === crongMax) {
        return 0
      } 
      // 포비가 크롱보다 클 경우 1점
      if (pobiMax > crongMax) {
        return 1
      } 
      // 포비가 크롱보다 작을 경우 2점
      if (pobiMax < crongMax) {
        return 2
      } 
    }

    console.log(solution());
  </script>
</body>
</html>